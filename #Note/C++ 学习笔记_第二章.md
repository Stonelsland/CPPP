# 第二章 变量和基本类型





####  2.1 基本内置类型

基本内置类型包括：

​	算数类型：

​					字符、整形、浮点型、布尔型

​	空型：空型不对应具体值，在函数需要传入空值或返回空值的时候才派上用场。



**2.1.1 算术类型**

char比较特殊，它最起码要放得下机器基本字符集中任意的一个字符，所以，它的大小最起码也要有一个机器字节那么大（通常是8`bit`）。

可寻址的最小内存块成为“**字节（byte)**”，而存储的基本单元是“**字（word)**”，一个**字**通常由若干个**字节**组成，大多数机器一个**字节**是8位（`bit`），一个字可能是32`bit`（4个字节）或者64`bit`（8个字节）。

在一个一个字节为8`bit`，一个字为4个字节的机器中，你可能会看到内存中一个字的区域内容如下：

```
736424	[0 0 1 1 1 0 1 1]		左侧是字节地址，右侧是字节中8位的每一位
736425	[0 0 0 1 1 0 1 1]
736426	[0 1 1 1 0 0 1 1]
736427	[0 1 1 0 0 1 0 0]
```

根据不同的数据类型需求，我们可以说一个地址是某种不同数据类型比特串的地址，如，地址为736424的那个字节，或者地址为736424的那个字，为了赋予某个地址明确的含义，必须首先知道存储在该地址内的数据类型，类型决定了数据所占比特数以及该如何解释这些比特内容，对应的地址也有了它自己的含义。

通常`float`类型用1个字（32比特）来表示，`double`用2个字（64比特）来表示。

**带符号类型和无符号类型**

**带符号类型**可以表示正数、负数和0，通过把8位中的一位用来表示正负号来达到目的。以前用过的int、float、double等都是带符号类型，可以表示正负和0，通过在这些类型名前面加unsigned就可以得到无符号类型，从而只表达正数和0。其中`unsigned int`可以缩写位`unsigned`。

和其他整形不同，字符型（也是整形数据中的一种）被分为了三种`char`、`signed char`、`unsigned char`。尽管看上去字符的表现形式有3种，但实际上却只有两种：带符号和无符号。类型`char`会表现为`char`和`signed char`中的一种，具体是哪一种，由编译器决定。而无符号类型——`unsigned cahr`可以表示0-255区间内的值。

**如何选择类型**

- 明确知晓数据值不可能为负数，选用无符号类型
- 对整数而言，`short`一般太小，而`int`和`long`一般一样大，所以当`int`长度不够时，考虑用`long long`
- 算术表达式中不要使用`char`或`bool`，，只有在存放字符或者布尔值的时候才使用它们，因为类型`char`在一些机器上是有符号的，而在另一些机器上又是无符号的，这样一来代码迁移可能会出错。如果你需要一个不大的整数，那么明确指出它的类型是`signed char`或者`unsigned char`。
- 执行浮点精度选用`double`，因为在精度方面，`double`比`float`精度更高，而在计算机代价上二者相差无几。甚至在有些机器上，`double`比`float`运行还快。对于`long double`提供的精度一般来说没必要，而且其在运行时带来的消耗也不容忽视。

#### 原码、反码、补码

​	原码：负数+负数、正数+负数结果不正确

​	反码：解决了正数+负数，但是负数+负数还是不对。

​	补码：解决了所有问题。

对正数来讲：原码、反码、补码都是他自己，因为正数和正数的运算不会出问题；对负数来讲，反码是除符号位之外，各个位1/0对调，补码是从低位向高位，第一个不为0的那位起，它左边所有位（符号位除外）按位取反，它右边保持不变。对于减法来说，减去一个数，等于加上这个数的同余数，例如，现在是10点，到达8点的方法有两个：时针回调2小时（10-2=8），或者时针往后调10小时（10+10=10+2+8=8），这里，12是它的模，到达12后，下一个数就是1，所以-2=+10。

对于那个问题：

```
unsigned u = 10;
int i = -42;
cout << i + i << endl; // -84,没有问题
cout << i + u << endl; // 4294967264
```

第二个表达式中，`i`本为有符号数，在内存中的数据为：1111,1111,1111,1111,1111,1111,1101,0110（有符号数，且为负数，计算机中均以补码形式存储，所以是32的int类型数据是这样的）。但是为了和unsigned数值一起运算，不得不把自己内存中的数字视作无符号数，也就是无视首位的1，这个1不再代表它是一个负数，这全部32位是一个无符号数，代表十进制的4294967254。所以这里的`i + u`才会是这个结果。



**总之**，类型转换，把一个超出这个类型所能表达的范围之外的数，强行赋值给这个类型，就可能出错。