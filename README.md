#NOAH的C++笔记
###### 2020.4.11
#### test
* 方法定义在头文件 方法声明在头文件引入和main函数之间
* for循环（）语句中i++ 与 ++i 是没有区别的 
for（init-statement; condition; expression）{statement}
执行顺序为init-statement -> condition -> statement -> expression 
###### 2020.4.12
#### fibo_seq
* 面向过程的编程思想
* inline内联函数: 
    个人理解：为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，将代码逻辑较为简单（不能含循环 递归等）且可能会被频繁重复调用的函数声明为内联函数，以代码膨胀为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率
##### 【注】
1. 每个调用内联函数的文件都应出现该内联函数的定义，否则则为非内联函数调用
2. 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。
3. 内联函数关键字inline必须与函数定义在一起才可成为内联
    如下风格的函数Foo 不能成为内联函数：
    `inline void Foo(int x, int y); // inline 仅与函数声明放在一起
    void Foo(int x, int y){}`
    而如下风格的函数Foo 则成为内联函数：
    `void Foo(int x, int y);
    inline void Foo(int x, int y) {} // inline 与函数定义体放在一起`
4. 以下情况不宜使用内联： 
（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 
（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心*构造函数和析构函数可能会隐藏一些行为*，如“偷偷地”执行了*基类或成员对象*的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。
    
